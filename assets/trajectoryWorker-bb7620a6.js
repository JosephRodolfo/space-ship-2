(function(){"use strict";const h=6.674*Math.pow(10,-11);class p{constructor(){}calculateGravitationalForce(t,a){const{distance:e,distanceX:c,distanceY:s}=this.calculateDistance(t.position,a.position),i=h*t.mass*a.mass/e**2,o={x:c/e,y:s/e};return{x:o.x*i,y:o.y*i}}calculateDistance(t,a){const e=a.x-t.x,c=a.y-t.y;return{distance:Math.sqrt(e**2+c**2),distanceX:e,distanceY:c}}calculateVelocity({acceleration:t,initialVelocity:a,timeStep:e}){return{x:a.x+=t.x*e,y:a.y+=t.y*e}}calculateAcceleration({force:t,mass:a}){return{x:t.x/a,y:t.y/a}}calculatePosition({position:t,velocity:a,timeStep:e}){return{x:t.x+a.x*e,y:t.y+a.y*e}}advanceTimeStep({ship:t,otherBodies:a,thrustForce:e,timeStep:c,isTrajectory:s=!1,callback:i}){const o=s?a.filter(({name:u})=>u==="earth"):a,n=this.sumForces(o,t);n.x+=e.x,n.y+=e.y;const l=this.calculateAcceleration({force:n,mass:t.mass}),r=this.calculateVelocity({acceleration:l,initialVelocity:t.velocity,timeStep:c}),y=this.calculatePosition({position:t.position,velocity:r,timeStep:c}),x=a.map(u=>this.calculateCelestialBody(u,a.filter(d=>d!==u),c));i({newPosition:y,newAcceleration:l,newVelocity:r,otherBodiesState:x})}calculateCelestialBody(t,a,e){const c=this.sumForces(a,t),s=this.calculateAcceleration({force:c,mass:t.mass}),i=this.calculateVelocity({acceleration:s,initialVelocity:t.velocity,timeStep:e});return{position:this.calculatePosition({position:t.position,velocity:i,timeStep:e}),acceleration:s,velocity:i,name:t.name}}sumForces(t=[],a){return t.reduce((e,c)=>{const s=this.calculateGravitationalForce(a,c);return{x:e.x+s.x,y:e.y+s.y}},{x:0,y:0})}calculateTrajectory(t,a,e,c){const[s,i]=e;let o=[],n={...t},l=a;for(let r=s;r<=i;r+=c)this.advanceTimeStep({ship:n,thrustForce:{x:0,y:0},otherBodies:l,timeStep:c,isTrajectory:!0,callback:({newPosition:y,newVelocity:x,newAcceleration:u,otherBodiesState:d})=>{o.push(y),n.position=y,n.velocity=x,n.acceleration=u,l=d.map(v=>{const f=l.find(({name:w})=>w===v.name);return f||v})}});return{trajectory:o,finalShipState:{acceleration:n.acceleration,velocity:n.velocity,position:o[o.length-1],mass:n.mass}}}detectCollision(t,a){const e=t.position.x-a.position.x,c=t.position.y-a.position.y,s=e*e+c*c,i=(t.radius+a.radius)*(t.radius+a.radius);return s<i}calculateOribitalVelocity(t,a){return Math.sqrt(h*a/t)}calculateRelativeVelocity(t,a){return{x:t.x-a.x,y:t.y-a.y}}calculateRelativePosition(t,a){return{x:t.x-a.x,y:t.y-a.y}}calculateRelativeAcceleration(t,a){return{x:t.x-a.x,y:t.y-a.y}}}const S=new p;self.addEventListener("message",m=>{const{otherBodies:t,window:a,shipData:e,timeStep:c}=m.data,s=1e3,i=a[1];let o={...e};for(let n=a[0];n<i;n+=s+1){const l=Math.min(n+s,i),r=[n,l],{trajectory:y,finalShipState:x}=S.calculateTrajectory(o,t,r,c);o=x,postMessage({chunk:y.filter((u,d)=>d%50===0)})}})})();
