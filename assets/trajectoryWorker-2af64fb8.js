(function(){"use strict";const v=6.674*Math.pow(10,-11);class M{constructor(){}calculateGravitationalForce(t,e){const{distance:a,distanceX:c,distanceY:s}=this.calculateDistance(t.position,e.position),o=v*t.mass*e.mass/a**2,n={x:c/a,y:s/a};return{x:n.x*o,y:n.y*o}}calculateDistance(t,e){const a=e.x-t.x,c=e.y-t.y;return{distance:Math.sqrt(a**2+c**2),distanceX:a,distanceY:c}}calculateVelocity({acceleration:t,initialVelocity:e,timeStep:a}){return{x:e.x+=t.x*a,y:e.y+=t.y*a}}calculateAcceleration({force:t,mass:e}){return{x:t.x/e,y:t.y/e}}calculatePosition({position:t,velocity:e,timeStep:a}){return{x:t.x+e.x*a,y:t.y+e.y*a}}advanceTimeStep({ship:t,otherBodies:e,thrustForce:a,timeStep:c,callback:s}){const o=e,n=this.sumForces(o,t);n.x+=a.x,n.y+=a.y;const i=this.calculateAcceleration({force:n,mass:t.mass}),l=this.calculateVelocity({acceleration:i,initialVelocity:t.velocity,timeStep:c}),u=this.calculatePosition({position:t.position,velocity:l,timeStep:c}),d=e.map(x=>this.calculateCelestialBody(x,e.filter(r=>r!==x),c));s({newPosition:u,newAcceleration:i,newVelocity:l,otherBodiesState:d})}calculateCelestialBody(t,e,a){const c=this.sumForces(e,t),s=this.calculateAcceleration({force:c,mass:t.mass}),o=this.calculateVelocity({acceleration:s,initialVelocity:t.velocity,timeStep:a});return{position:this.calculatePosition({position:t.position,velocity:o,timeStep:a}),acceleration:s,velocity:o,name:t.name}}sumForces(t=[],e){return t.reduce((a,c)=>{const s=this.calculateGravitationalForce(e,c);return{x:a.x+s.x,y:a.y+s.y}},{x:0,y:0})}calculateTrajectory(t,e,a,c){const[s,o]=a;let n=[],i={...t},l=e;for(let u=s;u<=o;u+=c)this.advanceTimeStep({ship:i,thrustForce:{x:0,y:0},otherBodies:l,timeStep:c,isTrajectory:!0,callback:({newPosition:d,newVelocity:x,newAcceleration:r,otherBodiesState:h})=>{n.push({...d,index:u}),i.position=d,i.velocity=x,i.acceleration=r,l=h.map(y=>{const m=l.find(({name:f})=>f===y.name);return m||y})}});return{trajectory:n,finalShipState:{acceleration:i.acceleration,velocity:i.velocity,position:n[n.length-1],mass:i.mass}}}detectCollision(t,e){const a=t.position.x-e.position.x,c=t.position.y-e.position.y,s=a*a+c*c,o=(t.radius+e.radius)*(t.radius+e.radius);return s<o}calculateOribitalVelocity(t,e){return Math.sqrt(v*e/t)}calculateRelativeVelocity(t,e){return{x:t.x-e.x,y:t.y-e.y}}calculateRelativePosition(t,e){return{x:t.x-e.x,y:t.y-e.y}}calculateRelativeAcceleration(t,e){return{x:t.x-e.x,y:t.y-e.y}}}const g=new M;self.addEventListener("message",p=>{const{otherBodies:t,window:e,shipData:a,timeStep:c,granularityFactor:s}=p.data,o=e[1]-e[0],n=1e3,i=e[1],l=Math.ceil(o/c);let u=s?Math.ceil(l/s):20;u=Math.min(u,l);let d=Math.max(1,Math.floor(l/u)),x={...a},r=[];for(let y=e[0];y<i;y+=n){const m=Math.min(y+n,i),f=[y,m],{trajectory:S,finalShipState:w}=g.calculateTrajectory(x,t,f,c);x=w,r.push(...S)}let h=r.filter((y,m)=>m%d===0);h[h.length-1]!==r[r.length-1]&&h.push(r[r.length-1]),postMessage({chunk:h})})})();
